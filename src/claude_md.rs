use std::path::Path;

use crate::error::Result;

pub struct ClaudeMdVars<'a> {
    pub worktree_path: &'a str,
    pub worker_name: &'a str,
    pub branch_name: &'a str,
    pub project_name: &'a str,
    pub task_type: &'a str,
    pub detected_types: &'a str,
    pub compose_enabled: bool,
    pub compose_file: &'a str,
    pub compose_project: &'a str,
    pub app_port: u16,
    pub db_port: u16,
    pub redis_port: u16,
    pub shared_compose: bool,
    pub shared_grove_name: &'a str,
}

/// Load a user-provided claude-md template, or fall back to the built-in default.
/// Returns (template_content, is_custom).
pub fn load_or_default(groot_dir: &Path) -> Result<(String, bool)> {
    let custom_path = groot_dir.join("claude-md.template");
    if custom_path.exists() {
        let contents = std::fs::read_to_string(&custom_path)?;
        return Ok((contents, true));
    }
    Ok((default_template().to_string(), false))
}

/// Render template variables and conditional blocks.
///
/// Variable substitution: `{{VAR}}` → value
/// Conditional blocks (line-level, no nesting):
///   `{{#if COMPOSE_ENABLED}}` ... `{{/if}}` — include when true
///   `{{#if !COMPOSE_ENABLED}}` ... `{{/if}}` — include when false
pub fn render(template: &str, vars: &ClaudeMdVars) -> String {
    // First pass: resolve conditional blocks
    let mut output = String::new();
    let mut including = true;
    let mut in_conditional = false;

    for line in template.lines() {
        let trimmed = line.trim();

        if let Some(rest) = trimmed.strip_prefix("{{#if ") {
            if let Some(var_name) = rest.strip_suffix("}}") {
                let var_name = var_name.trim();
                in_conditional = true;
                let (negated, key) = if let Some(k) = var_name.strip_prefix('!') {
                    (true, k.trim())
                } else {
                    (false, var_name)
                };
                let val = resolve_var(key, vars);
                let is_true = val == "true";
                including = if negated { !is_true } else { is_true };
                continue;
            }
        }

        if trimmed == "{{/if}}" {
            in_conditional = false;
            including = true;
            continue;
        }

        if including {
            output.push_str(line);
            output.push('\n');
        }
    }

    // Second pass: variable substitution
    let _ = in_conditional; // suppress unused warning
    output = output.replace("{{WORKTREE_PATH}}", vars.worktree_path);
    output = output.replace("{{WORKER_NAME}}", vars.worker_name);
    output = output.replace("{{BRANCH_NAME}}", vars.branch_name);
    output = output.replace("{{PROJECT_NAME}}", vars.project_name);
    output = output.replace("{{TASK_TYPE}}", vars.task_type);
    output = output.replace("{{DETECTED_TYPES}}", vars.detected_types);
    output = output.replace(
        "{{COMPOSE_ENABLED}}",
        if vars.compose_enabled { "true" } else { "false" },
    );
    output = output.replace("{{COMPOSE_FILE}}", vars.compose_file);
    output = output.replace("{{COMPOSE_PROJECT}}", vars.compose_project);
    output = output.replace("{{APP_PORT}}", &vars.app_port.to_string());
    output = output.replace("{{DB_PORT}}", &vars.db_port.to_string());
    output = output.replace("{{REDIS_PORT}}", &vars.redis_port.to_string());
    output = output.replace(
        "{{SHARED_COMPOSE}}",
        if vars.shared_compose { "true" } else { "false" },
    );
    output = output.replace("{{SHARED_GROVE}}", vars.shared_grove_name);

    output
}

/// Resolve a conditional variable name to its string value.
fn resolve_var(name: &str, vars: &ClaudeMdVars) -> String {
    match name {
        "COMPOSE_ENABLED" => {
            if vars.compose_enabled {
                "true"
            } else {
                "false"
            }
        }
        "SHARED_COMPOSE" => {
            if vars.shared_compose {
                "true"
            } else {
                "false"
            }
        }
        "PLAIN_TREE" => {
            if !vars.compose_enabled && !vars.shared_compose {
                "true"
            } else {
                "false"
            }
        }
        _ => "",
    }
    .to_string()
}

/// Load template, render with vars, and write CLAUDE.md into the worktree.
pub fn generate(worktree_path: &Path, groot_dir: &Path, vars: &ClaudeMdVars) -> Result<()> {
    let (template, _is_custom) = load_or_default(groot_dir)?;
    let rendered = render(&template, vars);
    let output_path = worktree_path.join("CLAUDE.local.md");
    std::fs::write(&output_path, rendered)?;
    Ok(())
}

/// Built-in default CLAUDE.md template for groot environments.
pub fn default_template() -> &'static str {
    r#"# CLAUDE.local.md — Auto-generated by groot

## Environment Context

- **Project**: {{PROJECT_NAME}}
- **Task**: {{WORKER_NAME}}
- **Branch**: {{BRANCH_NAME}}
- **Task Type**: {{TASK_TYPE}}
- **Detected Types**: {{DETECTED_TYPES}}
- **Worktree**: `{{WORKTREE_PATH}}`

## Worktree Isolation

This is a groot worktree — an isolated copy of the repository for parallel development.

- You are working on branch `{{BRANCH_NAME}}`
- All changes should be scoped to the task: **{{WORKER_NAME}}**
- Do NOT switch branches — the worktree is locked to `{{BRANCH_NAME}}`
- Do NOT modify files outside this worktree

{{#if COMPOSE_ENABLED}}
## Docker Compose Environment

A containerized development environment is running for this grove.

- **Compose file**: `{{COMPOSE_FILE}}`
- **Compose project**: `{{COMPOSE_PROJECT}}`

### Running commands

All application commands (rails, rspec, rake, bundle, etc.) MUST be run inside the container using `docker compose exec`:

```bash
docker compose -f "{{COMPOSE_FILE}}" -p "{{COMPOSE_PROJECT}}" exec app <command>
```

Examples:

```bash
# Rails console
docker compose -f "{{COMPOSE_FILE}}" -p "{{COMPOSE_PROJECT}}" exec app rails console

# Run tests (uses test database to avoid clobbering dev data)
docker compose -f "{{COMPOSE_FILE}}" -p "{{COMPOSE_PROJECT}}" exec -e DATABASE_URL=postgres://postgres:postgres@db:5432/{{WORKER_NAME}}_test app rspec

# Run migrations
docker compose -f "{{COMPOSE_FILE}}" -p "{{COMPOSE_PROJECT}}" exec app rails db:migrate

# Install gems
docker compose -f "{{COMPOSE_FILE}}" -p "{{COMPOSE_PROJECT}}" exec app bundle install
```

### Ports

| Service | Host Port | Container Port |
|---------|-----------|----------------|
| App     | {{APP_PORT}} | 3000 |
| DB      | {{DB_PORT}} | 5432 |
| Redis   | {{REDIS_PORT}} | 6379 |

### Important

- Do NOT run `rails server`, `rspec`, `rake`, or other app commands directly on the host
- Do NOT modify the compose file at `{{COMPOSE_FILE}}`
- The app container mounts `{{WORKTREE_PATH}}` as `/app`
- Database URL: `postgres://postgres:postgres@db:5432/{{WORKER_NAME}}_dev`
- Test Database URL: `postgres://postgres:postgres@db:5432/{{WORKER_NAME}}_test`
- Redis URL: `redis://redis:6379/0`
- `DATABASE_URL_TEST` is set in the container environment — tests MUST override `DATABASE_URL` with the test URL (see rspec example above) to avoid clobbering dev data
{{/if}}
{{#if SHARED_COMPOSE}}
## Shared Compose Environment

This tree shares services from grove **{{SHARED_GROVE}}**.

### Service Ports (on host)

| Service | Host Port |
|---------|-----------|
| App     | {{APP_PORT}} |
| DB      | {{DB_PORT}} |
| Redis   | {{REDIS_PORT}} |

### Connecting to services

Run commands locally in this worktree. Connect to the grove's database and Redis via host ports:

- Database: `postgres://postgres:postgres@localhost:{{DB_PORT}}/{{WORKER_NAME}}_dev`
- Redis: `redis://localhost:{{REDIS_PORT}}/0`

### Important

- Do NOT run `docker compose` commands — the compose stack belongs to grove **{{SHARED_GROVE}}**
- Do NOT stop or modify the grove's containers
- Run application commands directly (e.g., `rails console`, `rspec`)
- Configure DATABASE_URL and REDIS_URL to use the host ports above
{{/if}}
{{#if PLAIN_TREE}}
## Local Development

No Docker Compose environment is configured for this tree.
Run all commands directly in this worktree directory.
{{/if}}

## Git Conventions

- Work only on branch `{{BRANCH_NAME}}`
- Use conventional commit messages (feat:, fix:, refactor:, chore:, etc.)
- Keep commits focused and atomic
- Do NOT force-push or rebase shared branches
"#
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_vars() -> ClaudeMdVars<'static> {
        ClaudeMdVars {
            worktree_path: "/tmp/worktrees/fix-login",
            worker_name: "fix-login",
            branch_name: "myproj/bugfix/fix-login",
            project_name: "myproj",
            task_type: "bugfix",
            detected_types: "rails, ruby",
            compose_enabled: true,
            compose_file: "/tmp/compose/fix-login/docker-compose.yml",
            compose_project: "groot-fix-login",
            app_port: 3001,
            db_port: 5433,
            redis_port: 6380,
            shared_compose: false,
            shared_grove_name: "",
        }
    }

    #[test]
    fn test_render_with_compose_enabled() {
        let vars = test_vars();
        let rendered = render(default_template(), &vars);

        assert!(rendered.contains("**Project**: myproj"));
        assert!(rendered.contains("**Task**: fix-login"));
        assert!(rendered.contains("docker compose -f"));
        assert!(rendered.contains("groot-fix-login"));
        assert!(rendered.contains("3001"));
        assert!(rendered.contains("5433"));
        assert!(rendered.contains("6380"));
        // Should NOT contain the "no compose" section
        assert!(!rendered.contains("No Docker Compose environment"));
    }

    #[test]
    fn test_render_without_compose() {
        let mut vars = test_vars();
        vars.compose_enabled = false;
        let rendered = render(default_template(), &vars);

        assert!(rendered.contains("No Docker Compose environment"));
        // Should NOT contain compose exec instructions
        assert!(!rendered.contains("docker compose -f"));
    }

    #[test]
    fn test_conditional_blocks() {
        let template = "before\n{{#if COMPOSE_ENABLED}}\nincluded\n{{/if}}\nafter\n";
        let mut vars = test_vars();

        let rendered = render(template, &vars);
        assert!(rendered.contains("included"));
        assert!(rendered.contains("before"));
        assert!(rendered.contains("after"));

        vars.compose_enabled = false;
        let rendered = render(template, &vars);
        assert!(!rendered.contains("included"));
        assert!(rendered.contains("before"));
        assert!(rendered.contains("after"));
    }

    #[test]
    fn test_render_with_shared_compose() {
        let mut vars = test_vars();
        vars.compose_enabled = false;
        vars.shared_compose = true;
        vars.shared_grove_name = "base-feature";
        let rendered = render(default_template(), &vars);

        assert!(rendered.contains("Shared Compose Environment"));
        assert!(rendered.contains("base-feature"));
        assert!(rendered.contains("3001"));
        assert!(rendered.contains("5433"));
        assert!(rendered.contains("6380"));
        // Should NOT contain compose exec or plain tree sections
        assert!(!rendered.contains("docker compose -f"));
        assert!(!rendered.contains("No Docker Compose environment"));
    }

    #[test]
    fn test_negated_conditional() {
        let template = "{{#if !COMPOSE_ENABLED}}\nno compose\n{{/if}}\n";
        let mut vars = test_vars();

        vars.compose_enabled = true;
        let rendered = render(template, &vars);
        assert!(!rendered.contains("no compose"));

        vars.compose_enabled = false;
        let rendered = render(template, &vars);
        assert!(rendered.contains("no compose"));
    }
}
